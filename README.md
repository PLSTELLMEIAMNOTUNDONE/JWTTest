# Основное
Решение тестового задания <a href =  https://medods.notion.site/Test-task-BackDev-215fcddafff2425a8ca7e515e21527e7> Test task BackDev </a> <br>
Host name для MongoDB - mongodb://localhost:27017/ <br>
Имя бд - test, имя коллекции - users-tokens <br>
Базовый адрес приложения - http://localhost:5000/ <br>
Список Эндпоинтов:
1. /first?id="id" - выдает пару Access, Refresh токенов для пользователя с идентификатором id
1. /second - выполняет Refresh операцию на пару Access, Refresh токенов (которые передаются в теле запроса в json формате см след. параграф №9)
1. /swaggerd - Swagger UI (см след. параграф №1)
# Проблемы с которыми я столкнулся и то как я их решал
1. <h3>Покрывать ли код тестами/свагером?</h3> В задании этого не было указано, но для удобства использования сервиса я решил добавить эндпоинт со Swagger UI (http://localhost:5000/swaggerd) <br> Для мне пришлось добавить один лишний импорт - github.com/swaggo/http-swagger <br> На работу приложения это никак не влияет и носит чисто косметически характер, но если это критично я могу сделать версию без свагера(для этого достаточно удалить папку docs и упомянутый импорт) 
1. <h3>Как хранить переменные окружения?</h3> По хорошему, переменные вроде host name для монго, имя бд, и особенно секретного ключа для JWT токенов нужно хранить в .env файле, но это потребовало бы импортов дополнительных  библиотек, которые в задании указаны не были, поэтому все эти переменные я храню  коде в виде констант
1. <h3>Выбор http методов</h3> Ответы, как для первого, так и для второго эндпоинта, вообще говоря, не идемпотенты, поэтому для обоих я выбрал POST методы
1. <h3>Что хранить в базе данных?</h3> Схемы коллекции следующая: <br> Id - GUID  авторизированного пользователя, <br> RefToken - зашифрованный Refresh токен который был ему выдан ранее, и который еще не был использован для Кefresh операции (далее будем называть такие Refresh токены актуальными)
1. <h3>На первый эндпоинт пришел запрос с Id которого нет в бд, что делать?</h3> В задании речь идет об аутентификации, и я решил что пользователи, делающие запросы, должны уже быть авторизированы, а значит если их GUID нету в бд, то запрос на получение токенов не корректен и нужно кинуть error
1. <h3>Что будет представять из себя Refresh токен?</h3> Я решил генерировать случайный массив из 16 байт и создавать из него строку в кодировке base64, это гарантирует уникальность каждого токена 
1. <h3>Как выглядит GUID пользоватей?</h3> Я решил что GUID будет иметь вид строки (string) для просты работы с ним
1. <h3>Как связать Access и Refresh токены?</h3> При создании пары Access - Refresh токенов я сначала создаю Refresh, и затем загружаю его в payload (claims) Access токена. <br> При Refresh операции я проверяю я распаршиваю Access токен и проверяю что он соотвествует Refresh токену. <br> Кроме того в Claims Access токена я кладу GUID пользователя, который делает запрос, далее нам это понадобиться для проверки актуальности рефреш токена см №10
1. <h3>Как и какие аргументы приходят на второй эндпоинт?</h3> Для рефреш операции мне нужны оба Access и Refresh токены (иначе не возможно проверить были ли они выданы вместе), поэтому в теле запроса в виде json <br> Возникает вопрос будет ли Refresh токен зашифрован? Я решил что логичнее и безопаснее если это будет не так, Refresh токен приходит на этот эндпоинт в НЕзашифрованном виде 
1. <h3>Что вообще представляет из себя Refresh операция?</h3> Подробно опишу алгоритм: <br> 1. Достаем токены из тела запроса, парсим Access токен и проверяем что на равенство Refresh токен из его Claims и Refresh токен из запроса <br> 2. Нужно проверить что Refresh токен актуален, если это так то в базе данных у нас есть строчка Id - RefToken, где RefToken это зашифрованная версия нашего Refresh токена, а Id это id, которое лежит в Claims у Access токена. <br> Итак чтобы проверить актуальность Refresh токена мы достаем Id из Claims Access токена, находим его в бд, проверяем что RefToken лежащий в строке с этим id есть зашифрованный Refresh токен (c помощью bcrypt), и есил это так то наш токен актуален <br> 3. Создаем новую пару токенов и изменяем в бд для найденого пользователя RefToken на новый, таким образом каждый Refresh токен может быть использован единожды и только с Access токеном который был выдан вместе с ним.
